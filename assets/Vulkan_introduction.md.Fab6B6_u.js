import{_ as a,o as e,c as t,R as n}from"./chunks/framework.L_KMPG9f.js";const m=JSON.parse('{"title":"Introduction","description":"","frontmatter":{},"headers":[],"relativePath":"Vulkan/introduction.md","filePath":"Vulkan/introduction.md"}'),i={name:"Vulkan/introduction.md"},o=n('<h1 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">​</a></h1><h2 id="disclaimer" tabindex="-1">Disclaimer <a class="header-anchor" href="#disclaimer" aria-label="Permalink to &quot;Disclaimer&quot;">​</a></h2><p>This is by no way official documentation of Vulkan, but rather my own take and way of handling Vulkan code. By writing this myself I am forcing myself to do research on the workings of the vulkan API.</p><h2 id="what-is-vulkan" tabindex="-1">What is Vulkan? <a class="header-anchor" href="#what-is-vulkan" aria-label="Permalink to &quot;What is Vulkan?&quot;">​</a></h2><p>Vulkan is a graphics API just like OpenGL, DirectX and Metal. Vulkan is the successor of the OpenGL API and is cross-platform and actively maintained by the Khronos group. (Creaters of OpenGL)</p><p>The main problem with OpenGL and DirectX11 was that developers didn&#39;t have full control over how the graphics pipeline functioned, now with Vulkan the developers themselves can configurate the inner workings of the graphics pipeline just like DirectX12 can. With the main difference that Vulkan is cross platform.</p>',6),r=[o];function s(c,l,h,d,u,p){return e(),t("div",null,r)}const _=a(i,[["render",s]]);export{m as __pageData,_ as default};
