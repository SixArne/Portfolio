import{_ as e,o as a,c as s,R as n}from"./chunks/framework.z--if-CC.js";const m=JSON.parse('{"title":"Theory concepts that you must know","description":"","frontmatter":{},"headers":[],"relativePath":"Vulkan/concepts.md","filePath":"Vulkan/concepts.md"}'),i={name:"Vulkan/concepts.md"},t=n(`<h1 id="theory-concepts-that-you-must-know" tabindex="-1">Theory concepts that you must know <a class="header-anchor" href="#theory-concepts-that-you-must-know" aria-label="Permalink to &quot;Theory concepts that you must know&quot;">​</a></h1><p>When you create a vulkan application there are always some repetitive tasks that you have to do. Usually vulkan has 3 repetitive tasks:</p><ul><li>Querying information from the GPU</li><li>Creating &quot;Create info&quot; structs</li><li>Destroying these structs</li></ul><p>Generally when you call a function like <code>vkCreate...</code> you as the developer have the obligation to also destroy these created structs. There are also times were you just queue some information, getting info from the API does not require manual destruction.</p><details class="details custom-block"><summary>EXAMPLE MANUAL CLEANUP</summary><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VulkanApplication</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    VulkanApplication</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        VkInstanceCreateInfo createInfo{};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        createInfo.sType </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        createInfo.pApplicationInfo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">appInfo;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        VkResult result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> vkCreateInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">createInfo, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nullptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">m_Instance);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    ~VulkanApplication</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        vkDestroyInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(m_Instance, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nullptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    VkInstance m_Instance{};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div></details><h2 id="vkinstance" tabindex="-1">VkInstance <a class="header-anchor" href="#vkinstance" aria-label="Permalink to &quot;VkInstance&quot;">​</a></h2><p>Every vulkan application starts with creating an instance which describes your application and the extensions that it will be using. Here you can define things like an application and/or engine version.</p><h2 id="vkphysicaldevice" tabindex="-1">VkPhysicalDevice <a class="header-anchor" href="#vkphysicaldevice" aria-label="Permalink to &quot;VkPhysicalDevice&quot;">​</a></h2><p>The physical device is your computer&#39;s vulkan compatible graphics card, preferably you would chose a graphics card that supports as many features as possible. You can request all information and capabilities of your graphics card.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>We don&#39;t create a Physical device, we only ask vulkan to retrieve it for us. So this is one action that doesn&#39;t require manual cleanup.</p></div><h2 id="vkdevice" tabindex="-1">VkDevice <a class="header-anchor" href="#vkdevice" aria-label="Permalink to &quot;VkDevice&quot;">​</a></h2><p>The device or better known as the logical device is used to interface with the physical device, most functions that interact with the GPU will need a reference to this logical device. When creating a logical device we also need to see what type&#39;s of queue&#39;s are available on the card, as these are important for our feature-set.</p><h3 id="queue-types" tabindex="-1">Queue types <a class="header-anchor" href="#queue-types" aria-label="Permalink to &quot;Queue types&quot;">​</a></h3><p>An application will submit the data to a VkQueue in the form of <code>VkCommandBuffer</code> objects or sparse bindings.</p><p>There are numerous operations that a <code>VkQueue</code> can support. A Queue family describes a set of VkQueue&#39;s that have common properties and support the same functionality, as advertised in <code>VkQueueFamilyProperties</code>.</p><h3 id="graphics-vkqueue" tabindex="-1">Graphics VkQueue <a class="header-anchor" href="#graphics-vkqueue" aria-label="Permalink to &quot;Graphics VkQueue&quot;">​</a></h3><p>Uses the <code>VK_QUEUE_GRAPHICS_BIT</code> for <code>vkCmdDraw*</code> and the graphic pipeline commands.</p><h3 id="compute-vkqueue" tabindex="-1">Compute VkQueue <a class="header-anchor" href="#compute-vkqueue" aria-label="Permalink to &quot;Compute VkQueue&quot;">​</a></h3><p>Uses the <code>VK_QUEUE_COMPUTE_BIT</code> for <code>vkCmdDispatch*</code> and <code>vkCmdTraceRays*</code> and compute pipeline related commands.</p><h3 id="transfer-vkqueue" tabindex="-1">Transfer VkQueue <a class="header-anchor" href="#transfer-vkqueue" aria-label="Permalink to &quot;Transfer VkQueue&quot;">​</a></h3><p>Uses the <code>VK_QUEUE_TRANSFER_BIT</code> for all transfer commands</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Queue Families with only <code>VK_QUEUE_TRANSFER_BIT</code> are usually for using DMA to asynchronously transfer data between host and device memory on discrete GPUs, so transfers can be done concurrently with independent graphics/compute operations.</p><p><code>VK_QUEUE_GRAPHICS_BIT</code> and <code>VK_QUEUE_COMPUTE_BIT</code> can always implicitly accept <code>VK_QUEUE_TRANSFER_BIT</code> commands.</p></div><h3 id="sparse-vkqueue" tabindex="-1">Sparse VkQueue <a class="header-anchor" href="#sparse-vkqueue" aria-label="Permalink to &quot;Sparse VkQueue&quot;">​</a></h3><p><code>VK_QUEUE_SPARSE_BINDING_BIT</code> can be used for binding <a href="https://github.com/KhronosGroup/Vulkan-Guide/blob/master/chapters/sparse_resources.adoc#sparse-resources" target="_blank" rel="noreferrer">spare resources</a> to memory with the <code>vkQueueBindSparse</code> command</p><h3 id="protected-vkqueue" tabindex="-1">Protected VkQueue <a class="header-anchor" href="#protected-vkqueue" aria-label="Permalink to &quot;Protected VkQueue&quot;">​</a></h3><p><code>VK_QUEUE_PROTECTED_BIT</code> used for protected memory.</p><h3 id="video-decode-encode-vkqueue" tabindex="-1">Video Decode/Encode VkQueue <a class="header-anchor" href="#video-decode-encode-vkqueue" aria-label="Permalink to &quot;Video Decode/Encode VkQueue&quot;">​</a></h3><p><code>VK_QUEUE_VIDEO_DECODE_BIT_KHR</code> and <code>VK_QUEUE_VIDEO_ENCODE_BIT_KHR</code> used with Vulkan Video.</p><h2 id="window-surface" tabindex="-1">Window Surface <a class="header-anchor" href="#window-surface" aria-label="Permalink to &quot;Window Surface&quot;">​</a></h2><h2 id="swapchain" tabindex="-1">Swapchain <a class="header-anchor" href="#swapchain" aria-label="Permalink to &quot;Swapchain&quot;">​</a></h2><h2 id="image-views-and-framebuggers" tabindex="-1">Image views and framebuggers <a class="header-anchor" href="#image-views-and-framebuggers" aria-label="Permalink to &quot;Image views and framebuggers&quot;">​</a></h2><h2 id="render-passes" tabindex="-1">Render passes <a class="header-anchor" href="#render-passes" aria-label="Permalink to &quot;Render passes&quot;">​</a></h2><h2 id="graphics-pipeline" tabindex="-1">Graphics pipeline <a class="header-anchor" href="#graphics-pipeline" aria-label="Permalink to &quot;Graphics pipeline&quot;">​</a></h2><h2 id="command-pools-and-command-buffers" tabindex="-1">Command pools and command buffers <a class="header-anchor" href="#command-pools-and-command-buffers" aria-label="Permalink to &quot;Command pools and command buffers&quot;">​</a></h2><h2 id="sources" tabindex="-1">Sources <a class="header-anchor" href="#sources" aria-label="Permalink to &quot;Sources&quot;">​</a></h2><ul><li><a href="https://github.com/KhronosGroup/Vulkan-Guide/blob/master/chapters/queues.adoc" target="_blank" rel="noreferrer">Queues</a></li></ul>`,36),r=[t];function l(o,p,c,h,d,u){return a(),s("div",null,r)}const E=e(i,[["render",l]]);export{m as __pageData,E as default};
